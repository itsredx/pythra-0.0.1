<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Markdown Editor Test</title>
    <!-- ADD SIMPLEBAR CSS -->
    <link rel="stylesheet" href="./js/scroll-bar/simplebar.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link id="base-stylesheet" type="text/css" rel="stylesheet" href="styles.css?v=1761325888">
    <style id="dynamic-styles">
.shared-container-3 { box-sizing: border-box; background: white; padding: 16px; width: 100vw; height: 100vh; }
.shared-column-0 { display: flex; flex-direction: column; justify-content: flex-start; align-items: center; height: 100%; direction: ltr; }
.shared-row-0 { display: flex; flex-direction: row; justify-content: flex-start; align-items: center; width: 100%; direction: ltr; }

            .shared-text-0 {
                margin: 0; /* Reset default paragraph margin */
                padding: 0;
                color: black; font-size: 24px; font-weight: bold;
                
                
            }
            
.shared-elevatedbutton-0 { display: inline-flex; align-items: center; justify-content: center; padding: 8px 16px; margin: 4px; border: none; border-radius: 20px; background-color: blue; color: white; cursor: pointer; text-align: center; text-decoration: none; outline: none; box-sizing: border-box; overflow: hidden; position: relative; transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.15s linear; -webkit-appearance: none; -moz-appearance: none; appearance: none; box-shadow: 0px 1.0px 2.0px 0px rgba(0,0,0,0.15), 0px 2.0px 4.0px 1px rgba(0,0,0,0.10); }
.shared-elevatedbutton-0:hover { box-shadow: 0px 1.5px 3.0px 0px rgba(0,0,0,0.18), 0px 3.0px 6.0px 1px rgba(0,0,0,0.13); /* Add background overlay? */ }
.shared-elevatedbutton-0:active { box-shadow: none; /* Add background overlay? */ }
.shared-elevatedbutton-0.disabled { background-color: rgba(0, 0, 0, 0.12); color: rgba(0, 0, 0, 0.38); box-shadow: none; cursor: default; pointer-events: none; }


            .shared-text-1 {
                margin: 0; /* Reset default paragraph margin */
                padding: 0;
                
                
                
            }
            

.shared-container-2 { box-sizing: border-box; width: 100%; height: 70vh; }

.editor-container { box-sizing: border-box; width: 100%; height: 70vh; }

.shared-container-1 { box-sizing: border-box; width: 100%; height: 70vh; }

.editor-inner-container { box-sizing: border-box; width: 100%; height: 70vh; }

.shared-container-0 { box-sizing: border-box; width: 100%; height: 70vh; }</style>
    
        <script src="qwebchannel.js"></script>
        <script>
            // Suppress inset-area deprecation warnings
            (function() {
                const originalWarn = console.warn;
                console.warn = function(...args) {
                    const message = args.join(' ');
                    if (message.includes('inset-area') || 
                        message.includes('position-area') ||
                        message.includes('has been deprecated')) {
                        return; // Suppress these specific warnings
                    }
                    originalWarn.apply(console, args);
                };
            })();
            
            document.addEventListener('DOMContentLoaded', () => {
                new QWebChannel(qt.webChannelTransport, (channel) => {
                    window.pywebview = channel.objects.pywebview;
                    console.log("PyWebChannel connected.");
                });
            });
            function handleClick(name) { if(window.pywebview) window.pywebview.on_pressed_str(name, ()=>{}); }
            function handleClickWithArgs(callback_name, ...args) {
                if (window.pywebview) {
                    console.log("index", args);
                    window.pywebview.on_pressed(callback_name, ...args).then(function(response) {
                        console.log(response);
                    }).catch(function(error) {
                        console.error(error);
                    });
                } else {
                    console.error('pywebview is not defined');
                }
            }
            function handleItemTap(name, index) { if(window.pywebview) window.pywebview.on_item_tap(name, index, ()=>{}); }
            function handleInput(name, value) {
                if(window.pywebview) {
                    window.pywebview.on_input_changed(name, value, ()=>{});
                }
            }
        </script>
        
    
</head>
<body>
    <div id="root-container"><div id="fw_id_1" class=""><div id="fw_id_2" class="shared-container-3"><div id="fw_id_3" class="shared-column-0"><div id="fw_id_4" class="shared-row-0"><p id="fw_id_5" class="shared-text-0" style="color: black; font-size: 24; font-weight: bold">Markdown Editor  [Builds: 0] </p><button id="fw_id_6" class="shared-elevatedbutton-0" onclick="handleClick('increment')"><p id="fw_id_7" class="shared-text-1">increment</p></button></div><div id="fw_id_8" class="" style="height: 16px"></div><div id="fw_id_9" class="shared-row-0"><button id="fw_id_10" class="shared-elevatedbutton-0" onclick="handleClick('bold')"><p id="fw_id_11" class="shared-text-1">Bold</p></button><div id="fw_id_12" class="" style="width: 10px"></div><button id="fw_id_13" class="shared-elevatedbutton-0" onclick="handleClick('load_markdown')"><p id="fw_id_14" class="shared-text-1">Load MD</p></button><div id="fw_id_15" class="" style="width: 10px"></div><button id="fw_id_16" class="shared-elevatedbutton-0" onclick="handleClick('export_markdown')"><p id="fw_id_17" class="shared-text-1">Export MD</p></button></div><div id="fw_id_18" class="" style="height: 16px"></div><div id="fw_id_19" class="shared-container-2"><div id="fw_id_20" class="shared-container-1 editor-container"><div id="fw_id_21" class="shared-container-0 editor-inner-container"><div id="fw_id_23" class="shared-container-2"></div></div></div></div></div></div></div></div>
    <div id="overlay-container"></div>

    <!-- ADD SIMPLEBAR JS -->
    <script src="./js/scroll-bar/simplebar.min.js"></script>
    <!-- ADD THE NEW SLIDER JS ENGINE -->
    
        <script>
            document.addEventListener('DOMContentLoaded', () => {
                window._pythra_instances = window._pythra_instances || {};
                try {
                    // First, DEFINE all our JS classes and functions
                    // --- Injected from virtual_list.js ---
try {
/**
 * PythraVirtualList: A client-side engine for virtual scrolling. (Final Version)
 *
 * This engine creates its own SimpleBar instance to avoid race conditions.
 * It handles pre-rendered initial items (HTML and CSS) for an instant first paint.
 * It asynchronously fetches additional items from Python as the user scrolls.
 * Most importantly, it dynamically attaches event listeners to both pre-rendered
 * and asynchronously loaded content to ensure full interactivity.
 */
class PythraVirtualList {
    constructor(elementId, options) {
        this.container = document.getElementById(elementId);
        if (!this.container) {
            console.error(`VirtualList Error: Container element #${elementId} not found.`);
            return;
        }

        console.log(`✅ PythraVirtualList engine is initializing for #${elementId}`);
        
        this.options = options;
        this.simplebar = new SimpleBar(this.container, this.options.simplebarOptions || {});
        this.scrollEl = this.simplebar.getScrollElement();
        this.contentEl = this.simplebar.getContentElement();
        
        this.itemCache = {}; // Cache will ONLY store HTML strings.
        this.visibleItemElements = [];

        // Process the initialItems object from Python.
        if (this.options.initialItems) {
            const initialCss = new Set();
            for (const index in this.options.initialItems) {
                const itemData = this.options.initialItems[index];
                // 1. Store ONLY the HTML string in the cache.
                this.itemCache[index] = itemData.html;
                // 2. Collect all unique CSS rules.
                if (itemData.css) {
                    initialCss.add(itemData.css);
                }
            }
            // 3. Inject all collected CSS into the dynamic stylesheet in one go.
            if (initialCss.size > 0) {
                const styleSheet = document.getElementById('dynamic-styles');
                if (styleSheet) {
                    styleSheet.textContent += `\n${[...initialCss].join('\n')}`;
                }
            }
        }

        // Setup DOM for virtualization
        this.sizer = document.createElement('div');
        this.sizer.style.position = 'absolute';
        this.sizer.style.top = '0';
        this.sizer.style.left = '0';
        this.sizer.style.width = '1px';
        this.sizer.style.height = `${this.options.itemCount * this.options.itemExtent}px`;
        this.contentEl.appendChild(this.sizer);
        this.contentEl.style.position = 'relative';

        this.render = this.render.bind(this);
        this.scrollEl.addEventListener('scroll', this.render);
        
        this.render();
    }

    /**
     * Scans a newly rendered HTML fragment and attaches reliable event listeners
     * to elements that have an inline `onclick` attribute from the Python side.
     * @param {HTMLElement} element - The container element whose children to scan (e.g., the recycled list item div).
     */
    attachEventListeners(element) {
        const clickableElements = element.querySelectorAll('[onclick]');
        clickableElements.forEach(clickable => {
            const onclickAttr = clickable.getAttribute('onclick');
            
            // Regex to parse out the callback name from "handleClick('callback_name')"
            const match = onclickAttr.match(/handleClick\('([^']+)'\)/);

            if (match && match[1]) {
                const callbackName = match[1];
                // 1. Remove the inline attribute, as it's now redundant and less reliable.
                clickable.removeAttribute('onclick');
                // 2. Add a proper, trusted event listener.
                clickable.addEventListener('click', () => {
                    if (window.pywebview && typeof handleClick === 'function') {
                        // 3. Call the global handleClick function that communicates with Python.
                        handleClick(callbackName);
                    }
                });
            }
        });
    }

    render() {
        const scrollTop = this.scrollEl.scrollTop;
        const viewportHeight = this.scrollEl.clientHeight;

        const startIndex = Math.max(0, Math.floor(scrollTop / this.options.itemExtent));
        const endIndex = Math.min(
            this.options.itemCount - 1,
            Math.ceil((scrollTop + viewportHeight) / this.options.itemExtent)
        );
        
        const itemsToRender = [];
        for (let i = startIndex; i <= endIndex; i++) {
            itemsToRender.push({ index: i, top: i * this.options.itemExtent });
        }
        
        for (let i = 0; i < itemsToRender.length; i++) {
            const item = itemsToRender[i];
            let el = this.visibleItemElements[i];

            if (!el) {
                el = document.createElement('div');
                el.style.position = 'absolute';
                el.style.width = '100%';
                el.style.height = `${this.options.itemExtent}px`;
                el.style.left = '0';
                this.contentEl.appendChild(el);
                this.visibleItemElements.push(el);
            }

            el.style.transform = `translateY(${item.top}px)`;
            
            if (el.dataset.index !== String(item.index)) {
                el.dataset.index = item.index;
                
                if (this.itemCache[item.index]) {
                    // Item was pre-rendered or fetched before.
                    el.innerHTML = this.itemCache[item.index];
                    // IMPORTANT: We must re-attach listeners every time we set innerHTML.
                    this.attachEventListeners(el);
                } else {
                    // Item needs to be fetched from Python.
                    el.innerHTML = '<div>Loading...</div>';
                    if (window.pywebview && this.options.itemBuilderName) {
                        window.pywebview.build_list_item(this.options.itemBuilderName, item.index)
                            .then(response => {
                                const { html, css } = response;
                                this.itemCache[item.index] = html;

                                if (css) {
                                    const styleSheet = document.getElementById('dynamic-styles');
                                    if (styleSheet && !styleSheet.textContent.includes(css)) {
                                        styleSheet.textContent += `\n${css}`;
                                    }
                                }
                                
                                if (el.dataset.index === String(item.index)) {
                                    el.innerHTML = html;
                                    // Attach event listeners to the newly created DOM nodes.
                                    this.attachEventListeners(el);
                                }
                            })
                            .catch(e => {
                                console.error(`Error building virtual item ${item.index}:`, e);
                                if (el.dataset.index === String(item.index)) {
                                    el.innerHTML = '<div>Error</div>';
                                }
                            });
                    }
                }
            }
        }
        
        for (let i = itemsToRender.length; i < this.visibleItemElements.length; i++) {
            this.visibleItemElements[i].style.transform = 'translateY(-9999px)';
        }
    }

    /**
     * Called from Python when the underlying data for the list has changed.
     * Clears the cache and forces a re-render of all visible items.
     */
    refresh() {
        console.log(`Refreshing ALL visible items for #${this.container.id}`);
        // 1. Clear the entire HTML cache.
        this.itemCache = {};
        
        // 2. Mark all currently visible DOM elements as "dirty" by resetting their data-index.
        this.visibleItemElements.forEach(el => {
            el.dataset.index = '-1'; // Set to an invalid index
        });
        
        // 3. Trigger a render to fetch the new, updated content.
        this.render();
    }

    /**
     * Refreshes specific items by their indices. Highly efficient.
     * @param {Array<number>} indices - An array of item indices to refresh.
     */
    refreshItems(indices) {
        if (!Array.isArray(indices)) return;
        console.log(`Refreshing specific items for #${this.container.id}:`, indices);

        indices.forEach(index => {
            // 1. Invalidate the cache for this specific item.
            if (this.itemCache[index]) {
                delete this.itemCache[index];
            }
            
            // 2. Find if this item is currently visible in the DOM.
            const visibleElement = this.visibleItemElements.find(el => el.dataset.index === String(index));
            
            if (visibleElement) {
                // 3. If it's visible, mark it as dirty so the next render pass will update it.
                visibleElement.dataset.index = '-1';
            }
        });

        // 4. Trigger a render pass to update any newly dirtied elements.
        this.render();
    }
    
    // --- END OF NEW LOGIC ---

    destroy() {
        if (this.simplebar && typeof this.simplebar.unMount === 'function') {
            this.simplebar.unMount();
        }
    }
}

// Ensure classes are available globally
if (typeof ResponsiveClipPath !== 'undefined') window.ResponsiveClipPath = ResponsiveClipPath;
if (typeof PythraSlider !== 'undefined') window.PythraSlider = PythraSlider;
if (typeof PythraDropdown !== 'undefined') window.PythraDropdown = PythraDropdown;
if (typeof PythraGestureDetector !== 'undefined') window.PythraGestureDetector = PythraGestureDetector;
if (typeof PythraGradientClipPath !== 'undefined') window.PythraGradientClipPath = PythraGradientClipPath;
if (typeof PythraVirtualList !== 'undefined') window.PythraVirtualList = PythraVirtualList;
if (typeof generateRoundedPath !== 'undefined') window.generateRoundedPath = generateRoundedPath;
if (typeof scalePathAbsoluteMLA !== 'undefined') window.scalePathAbsoluteMLA = scalePathAbsoluteMLA;
} catch (e) {
    console.error('Error loading virtual_list.js:', e);
}

// --- Injected from dropdown.js ---
try {
/**
 * PythraDropdown: Client-side engine for a custom Dropdown widget.
 *
 * Handles toggling the dropdown menu, closing it when clicking outside,
 * and sending the selected value back to the Python backend.
 */
class PythraDropdown {
    constructor(elementId, options) {
        this.container = document.getElementById(elementId);
        if (!this.container) {
            console.error(`Dropdown container with ID #${elementId} not found.`);
            return;
        }

        console.log(`✅ PythraDropdown engine is initializing for #${elementId}`);

        this.options = options;
        this.valueContainer = this.container.querySelector('.dropdown-value-container');
        this.menu = this.container.querySelector('.dropdown-menu');
        this.items = this.menu.querySelectorAll('.dropdown-item');

        // Bind 'this' to maintain context in event handlers
        this.toggleMenu = this.toggleMenu.bind(this);
        this.handleItemClick = this.handleItemClick.bind(this);
        this.handleClickOutside = this.handleClickOutside.bind(this);

        // Attach event listeners
        this.valueContainer.addEventListener('click', this.toggleMenu);
        this.items.forEach(item => {
            item.addEventListener('click', this.handleItemClick);
        });
    }

    toggleMenu(event) {
        event.stopPropagation(); // Prevent click from bubbling to the document
        const isCurrentlyOpen = this.container.classList.toggle('open');
        console.log("Value container Clicked");
        
        if (isCurrentlyOpen) {
            // If we just opened the menu, listen for clicks outside to close it
            document.addEventListener('click', this.handleClickOutside);
        } else {
            // If we just closed it, stop listening
            document.removeEventListener('click', this.handleClickOutside);
        }
    }

    handleItemClick(event) {
        const selectedValue = event.currentTarget.dataset.value;
        const selectedLabel = event.currentTarget.textContent;

        console.log("Dropdown option Clicked");
        
        // 1. Update the display value immediately for instant feedback
        this.valueContainer.querySelector('span').textContent = selectedLabel;
        
        // 2. Send the selected *value* back to the Python backend
        if (window.pywebview && this.options.onChangedName) {
            window.pywebview.on_input_changed(this.options.onChangedName, selectedValue);
        }
        
        // 3. Close the menu
        this.closeMenu();
    }
    
    closeMenu() {
        if (this.container.classList.contains('open')) {
            this.container.classList.remove('open');
            document.removeEventListener('click', this.handleClickOutside);
        }
    }

    handleClickOutside(event) {
        // If the click is outside the main container, close the menu
        if (!this.container.contains(event.target)) {
            this.closeMenu();
        }
    }

    destroy() {
        // Cleanup to prevent memory leaks
        if (!this.container) return;
        this.valueContainer.removeEventListener('click', this.toggleMenu);
        this.items.forEach(item => {
            item.removeEventListener('click', this.handleItemClick);
        });
        document.removeEventListener('click', this.handleClickOutside);
    }
}

// Ensure classes are available globally
if (typeof ResponsiveClipPath !== 'undefined') window.ResponsiveClipPath = ResponsiveClipPath;
if (typeof PythraSlider !== 'undefined') window.PythraSlider = PythraSlider;
if (typeof PythraDropdown !== 'undefined') window.PythraDropdown = PythraDropdown;
if (typeof PythraGestureDetector !== 'undefined') window.PythraGestureDetector = PythraGestureDetector;
if (typeof PythraGradientClipPath !== 'undefined') window.PythraGradientClipPath = PythraGradientClipPath;
if (typeof PythraVirtualList !== 'undefined') window.PythraVirtualList = PythraVirtualList;
if (typeof generateRoundedPath !== 'undefined') window.generateRoundedPath = generateRoundedPath;
if (typeof scalePathAbsoluteMLA !== 'undefined') window.scalePathAbsoluteMLA = scalePathAbsoluteMLA;
} catch (e) {
    console.error('Error loading dropdown.js:', e);
}

// --- Injected from gradient_border.js ---
try {
/**
 * PythraGradientClipPath: Client-side engine for creating an animated
 * gradient border around a complex clip-path shape.
 */
'./pathGenerator.js';

// Helper function for basic vector math
const vec_gradient_border = (p1, p2) => ({ x: p2.x - p1.x, y: p2.y - p1.y });
const magnitude_gradient_border = (v) => Math.sqrt(v.x * v.x + v.y * v.y);
const normalize_gradient_border = (v) => {
    const mag = magnitude_gradient_border(v);
    return mag > 0 ? { x: v.x / mag, y: v.y / mag } : { x: 0, y: 0 };
};
const dot_gradient_border = (v1, v2) => v1.x * v2.x + v1.y * v2.y;
// const cross = (v1, v2) => v1.x * v2.y - v1.y * v2.x;



/**
 * Calculates a new set of points offset outwards from the original polygon.
 * @param {Array<Object>} points - The original points, e.g., [{x: 0, y: 0}, ...].
 * @param {number} offset - The distance to offset the points outwards.
 * @returns {Array<Object>} The new, offset points.
 */
function offsetPoints(points, offset) {
    const numPoints = points.length;
    if (numPoints < 3) return points;

    const offsetPoints = [];

    for (let i = 0; i < numPoints; i++) {
        const p_prev = points[(i + numPoints - 1) % numPoints];
        const p_curr = points[i];
        const p_next = points[(i + 1) % numPoints];

        const v1 = normalize_gradient_border(vec_gradient_border(p_curr, p_prev));
        const v2 = normalize_gradient_border(vec_gradient_border(p_curr, p_next));

        // Calculate the angle bisector vector (points outwards for convex shapes)
        const bisector = normalize_gradient_border({ x: v1.x + v2.x, y: v1.y + v2.y });

        // Calculate the angle between the two edge vectors
        const angle = Math.acos(dot_gradient_border(v1, v2));

        // Use trigonometry to find the length to move along the bisector
        // to achieve the desired perpendicular offset distance.
        const distance = offset / Math.sin(angle / 2);

        if (isNaN(distance) || !isFinite(distance)) {
             // Handle collinear points (angle is ~PI), just move along the normal
             const normal = { x: -v1.y, y: v1.x };
             offsetPoints.push({ x: p_curr.x + normal.x * offset, y: p_curr.y + normal.y * offset });
        } else {
             offsetPoints.push({ x: p_curr.x + bisector.x * distance, y: p_curr.y + bisector.y * distance });
        }
    }
    return offsetPoints;
}


class PythraGradientClipPath {
    constructor(elementId, options) {
        this.container = document.getElementById(elementId);
        if (!this.container) {
            console.error(`GradientClipPath container with ID #${elementId} not found.`);
            return;
        }

        console.log(`✅ PythraGradientClipPath engine is initializing for #${elementId}`);
        
        // --- Setup DOM Structure ---
        // The reconciler placed the child widget inside our container.
        // We need to wrap it and add a background element.
        this.backgroundEl = document.createElement('div');
        this.backgroundEl.className = 'gradient-clip-background';
        
        this.contentHost = document.createElement('div');
        this.contentHost.className = 'gradient-clip-content-host';

        // Move the original child from the container into the new host
        while (this.container.firstChild) {
            this.contentHost.appendChild(this.container.firstChild);
        }
        
        this.container.appendChild(this.backgroundEl);
        this.container.appendChild(this.contentHost);
        
        // --- Generate and Apply Paths ---
        this.options = options;
        this.update = this.update.bind(this);
        
        // Use a ResizeObserver to make it fully responsive
        this.ro = new ResizeObserver(this.update);
        this.ro.observe(this.container);
        
        // Initial update
        this.update();
    }

    update() {
        const rect = this.container.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) return;

        const { points, radius, viewBox, borderWidth } = this.options;
        const jsPoints = points.map(p => ({ x: p[0], y: p[1] }));

        // 1. Generate the inner path for the content
        const innerPathStr = generateRoundedPath(jsPoints, radius);
        const innerClipPath = `path("${innerPathStr}")`;

        // 2. Calculate offset points and a larger radius for the outer path
        const offset_points = offsetPoints(jsPoints, borderWidth);
        const outerRadius = radius + borderWidth;
        const outerPathStr = generateRoundedPath(offset_points, outerRadius);
        const outerClipPath = `path("${outerPathStr}")`;

        // 3. Apply the responsive clip-paths to the elements
        // We don't need ResponsiveClipPath class here because we update on every resize.
        this.contentHost.style.clipPath = innerClipPath;
        this.contentHost.style.webkitClipPath = innerClipPath;
        
        this.backgroundEl.style.clipPath = outerClipPath;
        this.backgroundEl.style.webkitClipPath = outerClipPath;
    }

    destroy() {
        if (this.ro && this.container) {
            this.ro.unobserve(this.container);
        }
    }
}

// Ensure classes are available globally
if (typeof ResponsiveClipPath !== 'undefined') window.ResponsiveClipPath = ResponsiveClipPath;
if (typeof PythraSlider !== 'undefined') window.PythraSlider = PythraSlider;
if (typeof PythraDropdown !== 'undefined') window.PythraDropdown = PythraDropdown;
if (typeof PythraGestureDetector !== 'undefined') window.PythraGestureDetector = PythraGestureDetector;
if (typeof PythraGradientClipPath !== 'undefined') window.PythraGradientClipPath = PythraGradientClipPath;
if (typeof PythraVirtualList !== 'undefined') window.PythraVirtualList = PythraVirtualList;
if (typeof generateRoundedPath !== 'undefined') window.generateRoundedPath = generateRoundedPath;
if (typeof scalePathAbsoluteMLA !== 'undefined') window.scalePathAbsoluteMLA = scalePathAbsoluteMLA;
} catch (e) {
    console.error('Error loading gradient_border.js:', e);
}

// --- Injected from gesture_detector.js ---
try {
/**
 * PythraGestureDetector: A client-side engine for a feature-rich gesture detector.
 *
 * It uses Pointer Events to handle mouse and touch统一. It disambiguates between
 * taps, double taps, long presses, and panning gestures.
 */
class PythraGestureDetector {
    constructor(elementId, options) {
        this.element = document.getElementById(elementId);
        if (!this.element) {
            console.error(`GestureDetector element with ID #${elementId} not found.`);
            return;
        }

        this.options = options;

        // --- Gesture State ---
        this.lastTapTime = 0;
        this.tapTimeout = null;
        this.longPressTimeout = null;
        this.isPanning = false;
        this.panStartPoint = { x: 0, y: 0 };
        this.panThreshold = 5; // Pixels to move before a pan is detected

        // --- Bind Handlers ---
        this.handlePointerDown = this.handlePointerDown.bind(this);
        this.handlePointerMove = this.handlePointerMove.bind(this);
        this.handlePointerUp = this.handlePointerUp.bind(this);
        this.fireTap = this.fireTap.bind(this);
        this.fireLongPress = this.fireLongPress.bind(this);

        // Attach the entry-point event listener
        this.element.addEventListener('pointerdown', this.handlePointerDown);
    }

    
    handlePointerDown(event) {
        // Only respond to the primary button (e.g., left mouse click)
        if (event.button !== 0) return;

        const currentTime = Date.now();

        // --- Double Tap Detection ---
        if (currentTime - this.lastTapTime < 300) { // 300ms window for double tap
            clearTimeout(this.tapTimeout);
            this.tapTimeout = null;
            this.lastTapTime = 0;
            if (this.options.onDoubleTapName) {
                window.pywebview.on_gesture_event(this.options.onDoubleTapName, {});
            }
            return;
        }
        
        this.lastTapTime = currentTime;
        this.panStartPoint = { x: event.clientX, y: event.clientY };

        // --- Long Press Detection ---
        if (this.options.onLongPressName) {
            this.longPressTimeout = setTimeout(() => this.fireLongPress(), 500); // 500ms for long press
        }

        // --- Single Tap Detection (will be fired later if not cancelled) ---
        if (this.options.onTapName) {
            this.tapTimeout = setTimeout(() => this.fireTap(), 300);
        }

        // Listen for move/up on the entire document for robust dragging
        document.addEventListener('pointermove', this.handlePointerMove);
        document.addEventListener('pointerup', this.handlePointerUp);
        document.addEventListener('pointercancel', this.handlePointerUp); // Treat cancel like up
    }

    handlePointerMove(event) {
        if (this.isPanning) {
            // --- Continue Panning ---
            const dx = event.clientX - this.panStartPoint.x;
            const dy = event.clientY - this.panStartPoint.y;
            if (this.options.onPanUpdateName) {
                window.pywebview.on_gesture_event(this.options.onPanUpdateName, { dx, dy });
            }
        } else {
            // --- Check if a Pan has Started ---
            const dx = event.clientX - this.panStartPoint.x;
            const dy = event.clientY - this.panStartPoint.y;
            if (Math.sqrt(dx * dx + dy * dy) > this.panThreshold) {
                this.isPanning = true;
                // A pan gesture cancels tap and long press
                clearTimeout(this.tapTimeout);
                this.tapTimeout = null;
                clearTimeout(this.longPressTimeout);
                this.longPressTimeout = null;
                
                if (this.options.onPanStartName) {
                    window.pywebview.on_gesture_event(this.options.onPanStartName, {});
                }
            }
        }
    }

    handlePointerUp(event) {
        // Clean up document-level listeners immediately
        document.removeEventListener('pointermove', this.handlePointerMove);
        document.removeEventListener('pointerup', this.handlePointerUp);
        document.removeEventListener('pointercancel', this.handlePointerUp);

        // Always clear a pending long press if pointer is lifted
        clearTimeout(this.longPressTimeout);
        this.longPressTimeout = null;
        
        if (this.isPanning) {
            // --- End Panning ---
            this.isPanning = false;
            if (this.options.onPanEndName) {
                window.pywebview.on_gesture_event(this.options.onPanEndName, );
            }
        }
    }

    fireTap() {
        if (this.tapTimeout) { // Ensure it wasn't cancelled
            this.tapTimeout = null;
            if (this.options.onTapName) {
                window.pywebview.on_gesture_event(this.options.onTapName, {});
            }
        }
    }
    
    fireLongPress() {
        // A long press cancels a single tap
        clearTimeout(this.tapTimeout);
        this.tapTimeout = null;
        this.lastTapTime = 0; // Prevent next tap from being a double tap
        
        if (this.longPressTimeout) {
            this.longPressTimeout = null;
            if (this.options.onLongPressName) {
                window.pywebview.on_gesture_event(this.options.onLongPressName, {});
            }
        }
    }

    destroy() {
        if (!this.element) return;
        this.element.removeEventListener('pointerdown', this.handlePointerDown);
        this.handlePointerUp(); // Ensure document listeners are cleaned up
        clearTimeout(this.tapTimeout);
        clearTimeout(this.longPressTimeout);
    }
}

// Ensure classes are available globally
if (typeof ResponsiveClipPath !== 'undefined') window.ResponsiveClipPath = ResponsiveClipPath;
if (typeof PythraSlider !== 'undefined') window.PythraSlider = PythraSlider;
if (typeof PythraDropdown !== 'undefined') window.PythraDropdown = PythraDropdown;
if (typeof PythraGestureDetector !== 'undefined') window.PythraGestureDetector = PythraGestureDetector;
if (typeof PythraGradientClipPath !== 'undefined') window.PythraGradientClipPath = PythraGradientClipPath;
if (typeof PythraVirtualList !== 'undefined') window.PythraVirtualList = PythraVirtualList;
if (typeof generateRoundedPath !== 'undefined') window.generateRoundedPath = generateRoundedPath;
if (typeof scalePathAbsoluteMLA !== 'undefined') window.scalePathAbsoluteMLA = scalePathAbsoluteMLA;
} catch (e) {
    console.error('Error loading gesture_detector.js:', e);
}

// --- Injected from pathGenerator.js ---
try {
// js/pathGenerator.js

// --- Vector Math Helper Functions ---
const vec = (p1, p2) => ({ x: p2.x - p1.x, y: p2.y - p1.y });
const magnitude = (v) => Math.sqrt(v.x ** 2 + v.y ** 2);
const dot = (v1, v2) => v1.x * v2.x + v1.y * v2.y;
const cross = (v1, v2) => v1.x * v2.y - v1.y * v2.x;
const round = (val) => Math.round(val * 100) / 100; // Round to 2 decimal places

function generateRoundedPath(points, radius) {
    const numPoints = points.length;
    const cornerData = [];

    console.log(`>>>>>> Generator Initiated <<<<<<`)

    for (let i = 0; i < numPoints; i++) {
        const p_prev = points[(i + numPoints - 1) % numPoints];
        const p_curr = points[i];
        const p_next = points[(i + 1) % numPoints];

        const v1 = vec(p_curr, p_prev);
        const v2 = vec(p_curr, p_next);
        const v1_mag = magnitude(v1);
        const v2_mag = magnitude(v2);

        if (v1_mag === 0 || v2_mag === 0) {
            cornerData.push({ t1: p_curr, t2: p_curr, radius: 0 });
            continue;
        }

        const angle = Math.acos(Math.max(-1, Math.min(1, dot(v1, v2) / (v1_mag * v2_mag))));
        let tangentDist = radius / Math.tan(angle / 2);
        tangentDist = Math.min(tangentDist, v1_mag / 2, v2_mag / 2);
        const clampedRadius = Math.abs(tangentDist * Math.tan(angle / 2));

        const t1 = { x: p_curr.x + (v1.x / v1_mag) * tangentDist, y: p_curr.y + (v1.y / v1_mag) * tangentDist };
        const t2 = { x: p_curr.x + (v2.x / v2_mag) * tangentDist, y: p_curr.y + (v2.y / v2_mag) * tangentDist };

        const sweepFlag = cross(v1, v2) < 0 ? 1 : 0;

        cornerData.push({ t1, t2, radius: clampedRadius, sweepFlag });
    }

    const pathCommands = [];
    pathCommands.push(`M ${round(cornerData[numPoints - 1].t2.x)} ${round(cornerData[numPoints - 1].t2.y)}`);
    for (let i = 0; i < numPoints; i++) {
        const corner = cornerData[i];
        pathCommands.push(`L ${round(corner.t1.x)} ${round(corner.t1.y)}`);
        pathCommands.push(`A ${round(corner.radius)} ${round(corner.radius)} 0 0 ${corner.sweepFlag} ${round(corner.t2.x)} ${round(corner.t2.y)}`);
    }
    pathCommands.push('Z');
    console.log(pathCommands.join(' '));
    return pathCommands.join(' ');
}


// Ensure classes are available globally
if (typeof ResponsiveClipPath !== 'undefined') window.ResponsiveClipPath = ResponsiveClipPath;
if (typeof PythraSlider !== 'undefined') window.PythraSlider = PythraSlider;
if (typeof PythraDropdown !== 'undefined') window.PythraDropdown = PythraDropdown;
if (typeof PythraGestureDetector !== 'undefined') window.PythraGestureDetector = PythraGestureDetector;
if (typeof PythraGradientClipPath !== 'undefined') window.PythraGradientClipPath = PythraGradientClipPath;
if (typeof PythraVirtualList !== 'undefined') window.PythraVirtualList = PythraVirtualList;
if (typeof generateRoundedPath !== 'undefined') window.generateRoundedPath = generateRoundedPath;
if (typeof scalePathAbsoluteMLA !== 'undefined') window.scalePathAbsoluteMLA = scalePathAbsoluteMLA;
} catch (e) {
    console.error('Error loading pathGenerator.js:', e);
}

// --- Injected from clipPathUtils.js ---
try {
// clipPathUtils.js

/**
 * Parse an SVG path string containing absolute commands (M, L, A, H, V, Z),
 * and scale coordinates from reference dimensions to target dimensions.
 * 
 * @param {string} pathStr - Original SVG path string (absolute commands only)
 * @param {number} refW - reference width
 * @param {number} refH - reference height
 * @param {number} targetW - actual element width
 * @param {number} targetH - actual element height
 * @param {Object} [options] - optional settings:
 *    - {boolean} uniformArc
 *    - {number} decimalPlaces
 *    - {boolean} percentOutput
 * @returns {string} - scaled path string
 */
// clipPathUtils.js

function scalePathAbsoluteMLA(pathStr, refW, refH, targetW, targetH, options = {}) {
  const rw = targetW / refW;
  const rh = targetH / refH;
  const uniformArc = !!options.uniformArc;
  const decimalPlaces = typeof options.decimalPlaces === 'number' ? options.decimalPlaces : null;
  const rScale = uniformArc ? Math.min(rw, rh) : null;

  const fmt = (num) => {
    return decimalPlaces !== null
      ? Number(num.toFixed(decimalPlaces)).toString()
      : Number(num).toString();
  };

  // Normalize the string
  const s = pathStr
    .replace(/,/g, ' ')
    .replace(/([0-9])-/g, '$1 -')
    .replace(/\s+/g, ' ')
    .trim();

  const tokenRegex = /([MLAZHV])|(-?\d*\.?\d+(?:e[-+]?\d+)?)/gi;
  const tokens = [];
  let match;
  while ((match = tokenRegex.exec(s)) !== null) {
    tokens.push(match[1] || match[2]);
  }

  const out = [];
  let i = 0;
  while (i < tokens.length) {
    const cmd = tokens[i++];
    out.push(cmd);

    switch (cmd) {
      case 'M':
      case 'L':
        while (i + 1 < tokens.length && !/^[MLAZHV]$/.test(tokens[i])) {
          const x = parseFloat(tokens[i++]) * rw;
          const y = parseFloat(tokens[i++]) * rh;
          out.push(fmt(x), fmt(y));
        }
        break;

      case 'A':
        while (i + 6 < tokens.length && !/^[MLAZHV]$/.test(tokens[i])) {
          const rx = parseFloat(tokens[i++]);
          const ry = parseFloat(tokens[i++]);
          const rot = tokens[i++];
          const laf = tokens[i++];
          const sf = tokens[i++];
          const x = parseFloat(tokens[i++]);
          const y = parseFloat(tokens[i++]);

          out.push(
            fmt(uniformArc ? rx * rScale : rx * rw),
            fmt(uniformArc ? ry * rScale : ry * rh),
            rot,
            laf,
            sf,
            fmt(x * rw),
            fmt(y * rh)
          );
        }
        break;

      case 'H':
        while (i < tokens.length && !/^[MLAZHV]$/.test(tokens[i])) {
          const x = parseFloat(tokens[i++]) * rw;
          out.push(fmt(x));
        }
        break;

      case 'V':
        while (i < tokens.length && !/^[MLAZHV]$/.test(tokens[i])) {
          const y = parseFloat(tokens[i++]) * rh;
          out.push(fmt(y));
        }
        break;

      case 'Z':
        // No coordinates to scale
        break;

      default:
        console.warn('Unsupported or unexpected token:', cmd);
    }
  }

  return out.join(' ');
}

class ResponsiveClipPath {
  constructor(target, originalPath, refW, refH, options = {}) {
    this.elements = [];
    this.orig = originalPath.trim();
    this.refW = refW;
    this.refH = refH;
    this.options = options;
    this.currentPath = "";  // ⬅️ Store last computed path string
    this.update = this.update.bind(this);
    this.roList = [];

    if (typeof target === 'string') {
      let selector = target;
      if (!selector.startsWith('#') && !selector.startsWith('.')) {
        const byId = document.getElementById(selector);
        selector = byId ? `#${selector}` : `.${selector}`;
      }
      const nodeList = document.querySelectorAll(selector);
      if (nodeList.length === 0) {
        console.warn(`ResponsiveClipPath: no elements found for selector "${selector}"`);
      }
      nodeList.forEach(el => this.elements.push(el));
    } else if (target instanceof HTMLElement) {
      this.elements.push(target);
    } else {
      console.warn('ResponsiveClipPath: invalid target', target);
    }

    this.elements.forEach(el => this.initElement(el));
  }

  initElement(el) {
    this.applyClip(el);
    if (window.ResizeObserver) {
      const ro = new ResizeObserver(() => this.applyClip(el));
      ro.observe(el);
      this.roList.push({ el, ro });
    } else {
      window.addEventListener('resize', this.update);
    }
  }

  applyClip(el) {
    const rect = el.getBoundingClientRect();
    const newPath = scalePathAbsoluteMLA(
      this.orig,
      this.refW,
      this.refH,
      rect.width,
      rect.height,
      this.options
    );
    this.currentPath = `path("${newPath}")`;  // ⬅️ Save it
    el.style.clipPath = this.currentPath;
    el.style.webkitClipPath = this.currentPath;
  }

  update() {
    this.elements.forEach(el => this.applyClip(el));
  }

  disconnect() {
    this.roList.forEach(({ el, ro }) => ro.unobserve(el));
    this.roList = [];
    window.removeEventListener('resize', this.update);
  }

  // ✅ Your new method
  getResponsivePath() {
    return this.currentPath;
  }
}


// Ensure classes are available globally
if (typeof ResponsiveClipPath !== 'undefined') window.ResponsiveClipPath = ResponsiveClipPath;
if (typeof PythraSlider !== 'undefined') window.PythraSlider = PythraSlider;
if (typeof PythraDropdown !== 'undefined') window.PythraDropdown = PythraDropdown;
if (typeof PythraGestureDetector !== 'undefined') window.PythraGestureDetector = PythraGestureDetector;
if (typeof PythraGradientClipPath !== 'undefined') window.PythraGradientClipPath = PythraGradientClipPath;
if (typeof PythraVirtualList !== 'undefined') window.PythraVirtualList = PythraVirtualList;
if (typeof generateRoundedPath !== 'undefined') window.generateRoundedPath = generateRoundedPath;
if (typeof scalePathAbsoluteMLA !== 'undefined') window.scalePathAbsoluteMLA = scalePathAbsoluteMLA;
} catch (e) {
    console.error('Error loading clipPathUtils.js:', e);
}

// --- Injected from slider.js ---
try {
/**
 * PythraSlider: A client-side engine for handling slider interactions.
 * This is now a proper JavaScript module class.
 */
class PythraSlider { // <-- ADD 'export' HERE
    constructor(elementId, options) {
        this.container = document.getElementById(elementId);
        if (!this.container) {
            console.error(`Slider container with ID #${elementId} not found.`);
            return;
        }

        console.log(`✅ PythraSlider engine is initializing for #${elementId}`);

        this.options = options;
        this.dragBool = false;
        
        // ... THE REST OF THE FILE REMAINS EXACTLY THE SAME ...
        this.track = this.container.querySelector('.slider-track');
        this.thumb = this.container.querySelector('.slider-thumb');
        
        this.handleDragStart = this.handleDragStart.bind(this);
        this.handleDragMove = this.handleDragMove.bind(this);
        this.handleDragEnd = this.handleDragEnd.bind(this);

        this.container.addEventListener('mousedown', this.handleDragStart);
        this.container.addEventListener('touchstart', this.handleDragStart, { passive: false });
    }

    handleDragStart(event) {
        event.preventDefault();
        this.container.classList.add('active');
        
        document.addEventListener('mousemove', this.handleDragMove);
        document.addEventListener('mouseup', this.handleDragEnd);
        document.addEventListener('touchmove', this.handleDragMove);
        document.addEventListener('touchend', this.handleDragEnd);


        this.updatePosition(event);
    }

    handleDragMove(event) {
        this.updatePosition(event);
    }

    handleDragEnd(event) {
        this.container.classList.remove('active');
        
        document.removeEventListener('mousemove', this.handleDragMove);
        document.removeEventListener('mouseup', this.handleDragEnd);
        document.removeEventListener('touchmove', this.handleDragMove);
        document.removeEventListener('touchend', this.handleDragEnd);
        // console.log("drag ended")
        this.dragBool = true;
        console.log("drag ended", this.dragBool, event);
        this.updatePosition(event);
    }

    updatePosition(event) {
        if (!this.track) return;
        const rect = this.track.getBoundingClientRect();
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        
        let positionX = clientX - rect.left;
        let percentage = (positionX / rect.width) * 100;
        
        percentage = Math.max(0, Math.min(100, percentage));
        
        this.container.style.setProperty('--slider-percentage', `${percentage}%`);
        console.log(percentage, this.options.onDragName);
        
        const range = this.options.max - this.options.min;
        const newValue = this.options.min + (percentage / 100) * range;
        console.log(percentage, this.options.onDragName, newValue);
        
        if (window.pywebview && this.options.onDragName) {
            window.pywebview.on_drag_update(this.options.onDragName, newValue, this.dragBool);
        }
        if (this.dragBool){
            console.log("hasDrag: Ended")
            this.dragBool = false
        } else {
            console.log("dragging")
        }
    }

    destroy() {
        if (!this.container) return;
        this.container.removeEventListener('mousedown', this.handleDragStart);
        this.container.removeEventListener('touchstart', this.handleDragStart);
        this.handleDragEnd();
    }
}

// Ensure classes are available globally
if (typeof ResponsiveClipPath !== 'undefined') window.ResponsiveClipPath = ResponsiveClipPath;
if (typeof PythraSlider !== 'undefined') window.PythraSlider = PythraSlider;
if (typeof PythraDropdown !== 'undefined') window.PythraDropdown = PythraDropdown;
if (typeof PythraGestureDetector !== 'undefined') window.PythraGestureDetector = PythraGestureDetector;
if (typeof PythraGradientClipPath !== 'undefined') window.PythraGradientClipPath = PythraGradientClipPath;
if (typeof PythraVirtualList !== 'undefined') window.PythraVirtualList = PythraVirtualList;
if (typeof generateRoundedPath !== 'undefined') window.generateRoundedPath = generateRoundedPath;
if (typeof scalePathAbsoluteMLA !== 'undefined') window.scalePathAbsoluteMLA = scalePathAbsoluteMLA;
} catch (e) {
    console.error('Error loading slider.js:', e);
}

// --- Injected Plugin 'pythra-markdown-editor': editor.js ---
try {
// PythraMarkdownEditor - A full-featured, self-contained, and memory-safe WYSIWYG Editor Engine
class PythraMarkdownEditor {
    constructor(elementOrId, options = {}) {
        if (typeof elementOrId === 'string') {
            this.container = document.getElementById(elementOrId);
            if (!this.container) {
                console.error(`PythraMarkdownEditor Error: Container with ID '${elementOrId}' not found.`);
                return;
            }
        } else {
            this.container = elementOrId;
        }

        this.options = options;
        this.options.showControls = this.options.showControls ?? true;
        this.editorElement = null;
        this._changeTimer = null;
        this._changeHandler = null;
        this._feedbackHandler = null;
        this.options.showGrid = this.options.showGrid ?? false;

        if (this.container) {
            this.container.style.width = this.options.width || '100%';
            this.container.style.height = this.options.height || 'auto';
        }

        if (!window._pythraEditorStylesInjected) {
            this.injectStyles();
            window._pythraEditorStylesInjected = true;
        }

        this.init();
    }

    init() {
        let controlPanel = this.container.querySelector('.control-panel');
        let editorEl = this.container.querySelector('[contenteditable="true"]');

        this.container.classList.add('pythra-editor-wrapper');

        if (this.options.showControls) {
            let toggleBtn = this.container.querySelector('.pythra-toggle-button');
            if (!controlPanel) {
                toggleBtn = document.createElement('button');
                toggleBtn.id = `toggleControls_${this.options.instanceId || ''}`;
                toggleBtn.className = 'pythra-toggle-button';
                // Prepend the button so it's always at the top
                this.container.prepend(toggleBtn);
                
                controlPanel = this.createControlPanel();
                // Insert after the toggle button
                toggleBtn.insertAdjacentElement('afterend', controlPanel);
            }
            
            // --- THIS IS THE FINAL FIX FOR PRESERVING HIDDEN STATE ---
            if (this.options.controlsInitiallyHidden && !controlPanel.classList.contains('hidden')) {
                controlPanel.classList.add('hidden');
            } else if (!this.options.controlsInitiallyHidden && controlPanel.classList.contains('hidden')) {
                controlPanel.classList.remove('hidden');
            }
            
            if (toggleBtn) {
                const isHidden = controlPanel.classList.contains('hidden');
                toggleBtn.textContent = isHidden ? 'Show Controls' : 'Hide Controls';
                toggleBtn.onclick = () => {
                    const isNowHidden = controlPanel.classList.toggle('hidden');
                    toggleBtn.textContent = isNowHidden ? 'Show Controls' : 'Hide Controls';
                    if (typeof handleInput === 'function' && this.options.onToggleControlsCallback) {
                        handleInput(this.options.onToggleControlsCallback, !isNowHidden);
                    }
                };
            }
        } else if (controlPanel) {
            const toggleBtn = this.container.querySelector('.pythra-toggle-button');
            if (toggleBtn) toggleBtn.remove();
            controlPanel.remove();
        }

        if (!editorEl) {
            editorEl = document.createElement('div');
            editorEl.id = this.options.instanceId ? `editor_${this.options.instanceId}` : 'editor';
            editorEl.contentEditable = true;
            this.container.appendChild(editorEl);
        }
        this.editorElement = editorEl;

        if (this.options.initialContent && this.editorElement.innerHTML !== this.options.initialContent) {
            this.editorElement.innerHTML = this.options.initialContent;
        }

        // --- NEW: Apply the grid class based on the option ---
        if (this.editorElement) {
            if (this.options.showGrid) {
                this.editorElement.classList.add('grid-background');
            } else {
                this.editorElement.classList.remove('grid-background');
            }
        }
        // --- END NEW LOGIC ---

        this._setupChangeHandler();
        this._setupVisualFeedbackHandlers();

        if (this.imageResizer) this.imageResizer.destroy();
        this.imageResizer = new PythraImageResizer(this.editorElement);
    }

    createControlPanel() {
        const panel = document.createElement('div');
        panel.id = `controlPanel_${this.options.instanceId || ''}`;
        panel.className = 'control-panel';

        const group1 = document.createElement('div');
        group1.className = 'control-group';
        [
            { cmd: 'formatBlock', val: 'H1', title: 'Heading 1', label: 'H1' },
            { cmd: 'formatBlock', val: 'H2', title: 'Heading 2', label: 'H2' },
            { cmd: 'formatBlock', val: 'P', title: 'Paragraph', label: 'P' },
            { cmd: 'insertUnorderedList', title: 'Unordered List', label: 'UL' },
            { cmd: 'insertOrderedList', title: 'Ordered List', label: 'OL' },
        ].forEach(c => group1.appendChild(this.createButton(c.cmd, c.label, c.title, c.val)));
        panel.appendChild(group1);

        const group2 = document.createElement('div');
        group2.className = 'control-group';
        [
            { id: `btn-bold_${this.options.instanceId}`, cmd: 'bold', title: 'Bold', label: '<b>B</b>' },
            { id: `btn-italic_${this.options.instanceId}`, cmd: 'italic', title: 'Italic', label: '<i>I</i>' },
            { id: `btn-underline_${this.options.instanceId}`, cmd: 'underline', title: 'Underline', label: '<u>U</u>' },
            { id: `btn-strikeThrough_${this.options.instanceId}`, cmd: 'strikeThrough', title: 'Strikethrough', label: '<s>S</s>' },
        ].forEach(c => group2.appendChild(this.createButton(c.cmd, c.label, c.title, null, c.id)));
        panel.appendChild(group2);

        const group3 = document.createElement('div');
        group3.className = 'control-group';
        group3.appendChild(this.createColorPicker());
        group3.appendChild(this.createFontSelector());
        panel.appendChild(group3);
        
        const group4 = document.createElement('div');
        group4.className = 'control-group';
        const insertImageBtn = this.createButton('insertImage', '🖼️', 'Insert Image');
        insertImageBtn.onclick = () => {
            const url = prompt("Enter the image URL:");
            if (url) {
                this.execCommand('insertImage', url);
            }
        };
        group4.appendChild(insertImageBtn);
        panel.appendChild(group4);

        return panel;
    }

    createButton(command, label, title, value = null, id = null) {
        const button = document.createElement('button');
        if (id) button.id = id;
        button.title = title;
        button.innerHTML = label;
        button.onclick = () => this.execCommand(command, value);
        return button;
    }

    createColorPicker() {
        const input = document.createElement('input');
        input.type = 'color';
        input.title = 'Font Color';
        input.oninput = (e) => this.execCommand('foreColor', e.target.value);
        return input;
    }

    createFontSelector() {
        const select = document.createElement('select');
        select.title = 'Font Family';
        select.onchange = (e) => this.execCommand('fontName', e.target.value);

        const fontsToUse = (this.options.fontList && Array.isArray(this.options.fontList) && this.options.fontList.length > 0)
            ? this.options.fontList
            : [ 
                { val: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif', label: 'System Default' },
                { val: 'Arial, sans-serif', label: 'Arial' },
                { val: "'Times New Roman', serif", label: 'Times New Roman' },
              ];
        
        fontsToUse.forEach(font => select.add(new Option(font.label, font.val)));
        return select;
    }

    _setupChangeHandler() {
        if (!this.editorElement) return;
        this._changeHandler = () => {
            clearTimeout(this._changeTimer);
            this._changeTimer = setTimeout(() => {
                const content = this.editorElement.innerHTML;
                if (typeof handleInput === 'function' && this.options.callback) {
                    handleInput(this.options.callback, content);
                }
            }, 180);
        };
        this.editorElement.addEventListener('input', this._changeHandler);
    }

    _setupVisualFeedbackHandlers() {
        if (!this.editorElement) return;
        this._feedbackHandler = () => this.updateButtonStates();
        ['keyup', 'mouseup', 'focus', 'click'].forEach(eventType => {
            this.editorElement.addEventListener(eventType, this._feedbackHandler);
        });
    }

    updateButtonStates() {
        ['bold', 'italic', 'underline', 'strikeThrough'].forEach(command => {
            const button = document.getElementById(`btn-${command}_${this.options.instanceId}`);
            if (!button) return;
            try {
                button.classList.toggle('active', document.queryCommandState(command));
            } catch (e) { /* This can safely fail if editor is not focused */ }
        });
    }
    
    injectStyles() {
        const style = document.createElement('style');
        style.id = 'pythra-editor-styles';
        style.textContent = `
            :root{--pe-color-primary:#007aff;--pe-color-primary-dark:#005bb5;--pe-color-surface:#ffffff;--pe-color-border:#dee2e6;--pe-color-text:#212529;--pe-color-text-muted:#6c757d;--pe-font-stack:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;--pe-border-radius:6px;}
            .pythra-editor-wrapper{box-sizing:border-box;display:flex;flex-direction:column;background:var(--pe-color-surface);border:1px solid var(--pe-color-border);border-radius:var(--pe-border-radius);box-shadow:0 4px 12px rgba(0,0,0,0.05);}
            .pythra-editor-wrapper [contenteditable]{font-family:var(--pe-font-stack);flex-grow:1;min-height:150px;border-top:1px solid var(--pe-color-border);padding:1.5rem;line-height:1.7;outline:none;overflow-y:auto;}
            .pythra-editor-wrapper [contenteditable]:focus{border-color:var(--pe-color-primary) !important;box-shadow:0 0 0 3px rgba(0,122,255,0.25)}
            .pythra-editor-wrapper [contenteditable]:empty:before{content:"Start writing...";color:var(--pe-color-text-muted);font-style:italic}
            .pythra-editor-wrapper .pythra-toggle-button{flex-shrink:0;width:100%;padding:0.75rem;font-size:1rem;font-weight:600;color:white;background-color:var(--pe-color-primary);border:none;border-radius:var(--pe-border-radius) var(--pe-border-radius) 0 0;cursor:pointer;transition:background-color 0.2s ease;}
            .pythra-editor-wrapper .pythra-toggle-button:hover{background-color:var(--pe-color-primary-dark)}
            .control-panel{flex-shrink:0;background:#f1f3f5;padding:1rem;display:flex;flex-direction:column;gap:1rem;transition:all 0.3s ease-in-out;max-height:1000px;opacity:1;overflow:hidden;}
            .control-panel.hidden{max-height:0;padding-top:0;padding-bottom:0;opacity:0;}
            .control-group{display:flex;flex-wrap:wrap;gap:0.5rem;align-items:center}
            .control-panel button,.control-panel select,.control-panel input[type="color"]{font-family:var(--pe-font-stack);font-size:0.9rem;padding:0.5rem 0.75rem;background:var(--pe-color-surface);border:1px solid var(--pe-color-border);border-radius:var(--pe-border-radius);cursor:pointer;transition:background-color 0.2s ease,border-color 0.2s ease, box-shadow 0.2s ease;}
            .control-panel button:hover,.control-panel select:hover{background:#e9ecef}
            .control-panel button.active{background-color:var(--pe-color-primary);color:white;border-color:var(--pe-color-primary-dark)}
            .control-panel select{-webkit-appearance:none;appearance:none;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right 0.5rem center;background-size:1em;padding-right:2rem;}
            .control-panel select:focus{border-color:var(--pe-color-primary);box-shadow:0 0 0 3px rgba(0,122,255,0.25);background-color:var(--pe-color-surface);}
            .control-panel input[type="color"]{padding:0.25rem;height:38px;min-width:40px;border:1px solid var(--pe-color-border);background:transparent}
            .pythra-image-resizer-wrapper{position:absolute;border:2px solid var(--pe-color-primary);pointer-events:none;}
            .pythra-resize-handle{position:absolute;width:10px;height:10px;background-color:var(--pe-color-primary);border:1px solid white;border-radius:50%;pointer-events:auto;}
            .pythra-resize-handle.top-left{top:-6px;left:-6px;cursor:nwse-resize;}
            .pythra-resize-handle.top-right{top:-6px;right:-6px;cursor:nesw-resize;}
            .pythra-resize-handle.bottom-left{bottom:-6px;left:-6px;cursor:nesw-resize;}
            .pythra-resize-handle.bottom-right{bottom:-6px;right:-6px;cursor:nwse-resize;}
            /* --- NEW: CSS for the dotted grid background --- */
            .pythra-editor-wrapper [contenteditable].grid-background {
                /* Creates a repeating pattern of dots */
                background-image: radial-gradient(circle, #D3D3D3 1px, rgba(0,0,0,0) 1px);
                background-size: 20px 20px; /* Adjust these values to change dot spacing */
            }
        `;
        document.head.appendChild(style);
    }
    
    execCommand(command, value = null) {
        if (!command) return;
        try {
            document.execCommand(command, false, value);
        } catch (err) {
            console.error(`Error executing command '${command}':`, err);
        }
        this.editorElement.focus();
        this.updateButtonStates();
    }

    setContent(html) { if (this.editorElement) this.editorElement.innerHTML = html; }
    getContent() { return this.editorElement ? this.editorElement.innerHTML : ''; }
    focus() { if (this.editorElement) this.editorElement.focus(); }

    destroy() {
        console.log(`🔥 Destroying PythraMarkdownEditor instance: ${this.options.instanceId}`);
        
        if (this.editorElement && this._changeHandler) {
            this.editorElement.removeEventListener('input', this._changeHandler);
        }
        if (this.editorElement && this._feedbackHandler) {
            ['keyup', 'mouseup', 'focus', 'click'].forEach(eventType => {
                this.editorElement.removeEventListener(eventType, this._feedbackHandler);
            });
        }
        
        if (this.imageResizer) {
            this.imageResizer.destroy();
        }

        clearTimeout(this._changeTimer);
    }
}

window.PythraMarkdownEditor = PythraMarkdownEditor;

document.addEventListener("DOMContentLoaded", () => {
    try {
        document.execCommand("styleWithCSS", false, true);
    } catch (e) {
        console.warn("styleWithCSS is not supported by this browser.");
    }
});

class PythraImageResizer {
    constructor(editorElement) {
        this.editor = editorElement;
        this.selectedImage = null;
        this.wrapper = null;
        this.handles = [];

        this.handleClick = this.handleClick.bind(this);
        this.handleMouseDown = this.handleMouseDown.bind(this);
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.handleMouseUp = this.handleMouseUp.bind(this);
        
        this.editor.addEventListener('click', this.handleClick);
    }

    handleClick(e) {
        const target = e.target;
        if (target.tagName === 'IMG') {
            if (this.selectedImage !== target) {
                this.selectImage(target);
            }
        } else if (this.selectedImage) {
            this.deselectImage();
        }
    }
    
    selectImage(img) {
        this.deselectImage();

        this.selectedImage = img;
        
        this.wrapper = document.createElement('div');
        this.wrapper.className = 'pythra-image-resizer-wrapper';
        // Append to editor's parent to avoid contenteditable issues
        this.editor.parentNode.appendChild(this.wrapper);
        this.positionWrapper();
        
        const handlePositions = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
        handlePositions.forEach(pos => {
            const handle = document.createElement('div');
            handle.className = `pythra-resize-handle ${pos}`;
            handle.dataset.position = pos;
            this.wrapper.appendChild(handle);
            handle.addEventListener('mousedown', this.handleMouseDown);
        });
    }
    
    deselectImage() {
        if (this.wrapper) {
            this.wrapper.remove();
            this.wrapper = null;
        }
        this.selectedImage = null;
    }
    
    positionWrapper() {
        if (!this.selectedImage || !this.wrapper) return;
        
        // This needs to be relative to the parent of the editor now
        const editorParent = this.editor.parentNode;
        this.editor.parentNode.style.position = this.editor.parentNode.style.position || 'relative';

        const imgRect = this.selectedImage.getBoundingClientRect();
        const parentRect = editorParent.getBoundingClientRect();
        
        this.wrapper.style.top = `${imgRect.top - parentRect.top}px`;
        this.wrapper.style.left = `${imgRect.left - parentRect.left}px`;
        this.wrapper.style.width = `${imgRect.width}px`;
        this.wrapper.style.height = `${imgRect.height}px`;
    }

    handleMouseDown(e) {
        e.preventDefault();
        e.stopPropagation();

        this.startRect = this.selectedImage.getBoundingClientRect();
        this.startPos = { x: e.clientX, y: e.clientY };
        this.handlePosition = e.target.dataset.position;

        document.addEventListener('mousemove', this.handleMouseMove);
        document.addEventListener('mouseup', this.handleMouseUp);
    }
    
    handleMouseMove(e) {
        if (!this.startRect) return;

        const dx = e.clientX - this.startPos.x;
        const dy = e.clientY - this.startPos.y;

        let newWidth = this.startRect.width;
        
        if (this.handlePosition.includes('right')) {
            newWidth += dx;
        } else if (this.handlePosition.includes('left')) {
            newWidth -= dx;
        }

        this.selectedImage.style.width = `${Math.max(20, newWidth)}px`;
        this.selectedImage.style.height = 'auto';
        
        this.positionWrapper();
    }

    handleMouseUp() {
        document.removeEventListener('mousemove', this.handleMouseMove);
        document.removeEventListener('mouseup', this.handleMouseUp);
        this.startRect = null;
        
        this.editor.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
    }

    destroy() {
        this.editor.removeEventListener('click', this.handleClick);
        this.deselectImage();
    }
}
} catch (e) {
    console.error('Error loading plugin pythra-markdown-editor - editor.js:', e);
}
                    
                    // Then, RUN the initialization commands that were generated
                    
                    function waitForAndInit(className, initCallback) {
                            const interval = setInterval(() => {
                                // Check if the class is now available on the window object
                                if (typeof window[className] === 'function') {
                                    clearInterval(interval); // Stop checking
                                    console.log(`Class ${className} is defined. Initializing...`);
                                    initCallback(); // Run the initialization code
                                } else {
                                    console.log(`Waiting for class ${className}...`);
                                }
                            }, 100); // Check every 100ms
                        }
                        waitForAndInit('PythraMarkdownEditor', () => {
                            window._pythra_instances['markdown_editor_PythraMarkdownEditor'] = new PythraMarkdownEditor(
                                document.getElementById('fw_id_23'),
                                {"callback": "markdown_content_change_markdown_editor", "instanceId": "markdown_editor_PythraMarkdownEditor", "showControls": false, "initialContent": "<h1>Welcome!</h1><p>Start writing your document here...</p>", "width": "100%", "height": "70vh", "showGrid": true}
                            );
                            
                        });
                        

                } catch (e) {
                    console.error("Error running Pythra initializers:", e);
                }
            });
        </script>
        
</body>
</html>